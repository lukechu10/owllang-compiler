var searchIndex = JSON.parse('{\
"owlc_cli":{"doc":"Driver code. Entrypoint into the CLI application is in…","i":[[5,"main","owlc_cli","",null,[[]]]],"p":[]},\
"owlc_driver":{"doc":"Driver code for owlc-cli","i":[[5,"println","owlc_driver","",null,[[]]],[5,"read_num","","",null,[[]]],[5,"driver","","",null,[[]]]],"p":[]},\
"owlc_error":{"doc":"Utilities for reporting errors during compilation.","i":[[3,"Error","owlc_error","Represents a compile error.",null,null],[12,"file_name","","The name of the file the error occurred in.",0,null],[12,"message","","The error message.",0,null],[12,"help_hint","","Optional help message.",0,null],[12,"loc","","The span data / location of the error.",0,null],[3,"ErrorReporter","","Handles all errors for a compilation unit. Use…",null,null],[11,"new","","",0,[[["string",3],["span",3]]]],[11,"with_help_hint","","",0,[[["string",3]]]],[11,"new","","Creates an empty `ErrorReporter` without any errors.",1,[[["sourcefile",3],["rc",3]]]],[11,"report","","Add an error to the `ErrorReporter`.",1,[[["error",3]]]],[11,"has_errors","","Returns `true` if there are errors reported.",1,[[]]],[11,"merge_from","","Consumes `error_reporter` and merges the errors into `self`.",1,[[["errorreporter",3]]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_string","","",1,[[],["string",3]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"clone","","",0,[[],["error",3]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]]],"p":[[3,"Error"],[3,"ErrorReporter"]]},\
"owlc_lexer":{"doc":"Owllang lexer implementation.","i":[[3,"Lexer","owlc_lexer","",null,null],[12,"src","","The string to read from.",0,null],[3,"Token","","Represents a single token.",null,null],[12,"kind","","The internal data of the token.",1,null],[12,"span","","The position of the `Token` in the `SourceFile`.",1,null],[4,"TokenKind","","Represents the value of a [`Token`].",null,null],[13,"PuncOpenParen","","`(`",2,null],[13,"PuncCloseParen","","`)`",2,null],[13,"PuncOpenBrace","","`{`",2,null],[13,"PuncCloseBrace","","`}`",2,null],[13,"PuncOpenSquare","","`[`",2,null],[13,"PuncCloseSquare","","`]`",2,null],[13,"PuncComma","","`,`",2,null],[13,"PuncSemi","","`;`",2,null],[13,"OpPlus","","`+`",2,null],[13,"OpMinus","","`-`",2,null],[13,"OpAsterisk","","`*`",2,null],[13,"OpSlash","","`/`",2,null],[13,"OpPercent","","`%` (for modulo operator)",2,null],[13,"OpEquals","","`=`",2,null],[13,"OpEqualsEquals","","`==`",2,null],[13,"OpGreaterThan","","`>`",2,null],[13,"OpEqualsGreaterThan","","`>=`",2,null],[13,"OpLessThan","","`<`",2,null],[13,"OpEqualsLessThan","","`<=`",2,null],[13,"OpDot","","`.` (for function composition)",2,null],[13,"KeywordFn","","",2,null],[13,"KeywordExtern","","",2,null],[13,"KeywordLet","","",2,null],[13,"KeywordIf","","",2,null],[13,"KeywordElse","","",2,null],[13,"KeywordWhile","","",2,null],[13,"KeywordFor","","",2,null],[13,"KeywordIn","","",2,null],[13,"KeywordReturn","","",2,null],[13,"Identifier","","",2,null],[13,"LiteralInt","","",2,null],[13,"LiteralDouble","","Note: Current unused.",2,null],[13,"EndOfFile","","",2,null],[11,"with_source_file","","",0,[[["errorreporter",3],["rc",3]]]],[11,"infix_binding_power","","Returns the infix binding power for an operator. If…",2,[[]]],[11,"prefix_binding_power","","Returns the prefix binding power for an operator. If…",2,[[]]],[11,"token_name","","Returns the display name of the `TokenKind`.",2,[[],["string",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"into_iter","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"to_string","","",2,[[],["string",3]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"next","","Returns the next token in the input or None if the end of…",0,[[],[["token",3],["option",4]]]],[11,"clone","","",1,[[],["token",3]]],[11,"clone","","",2,[[],["tokenkind",4]]],[11,"eq","","",1,[[["token",3]]]],[11,"ne","","",1,[[["token",3]]]],[11,"eq","","",2,[[["tokenkind",4]]]],[11,"ne","","",2,[[["tokenkind",4]]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"serialize","","",2,[[],["result",4]]],[11,"deserialize","","",2,[[],["result",4]]]],"p":[[3,"Lexer"],[3,"Token"],[4,"TokenKind"]]},\
"owlc_llvm":{"doc":"","i":[[3,"LlvmCodeGenVisitor","owlc_llvm","",null,null],[12,"module","","",0,null],[12,"builder","","",0,null],[12,"context","","",0,null],[11,"new","","",0,[[["llvmmoduleref",6],["llvmbuilderref",6]]]],[11,"build_entry_bb_alloca","","Creates an `alloca` instruction in the `entry` block of…",0,[[],["llvmvalueref",6]]],[11,"handle_repl_input","","Custom codegen function for repl.",0,[[["stmt",3]]]],[14,"c_str","","Utility to create *const i8 strings from &str",null,null],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"drop","","",0,[[]]],[11,"visit_literal_expr","","",0,[[]]],[11,"visit_identifier_expr","","",0,[[]]],[11,"visit_func_call","","",0,[[]]],[11,"visit_bin_expr","","",0,[[["tokenkind",4],["expr",3]]]],[11,"visit_fn_proto","","",0,[[]]],[11,"visit_fn_stmt","","",0,[[["fnproto",3],["option",4]]]],[11,"visit_while_stmt","","",0,[[["expr",3],["block",3]]]],[11,"visit_if_else_stmt","","",0,[[["option",4],["expr",3],["block",3]]]],[11,"visit_let_stmt","","",0,[[["expr",3]]]],[11,"visit_return_stmt","","",0,[[["expr",3]]]],[11,"visit_expr_semi_stmt","","",0,[[["expr",3]]]]],"p":[[3,"LlvmCodeGenVisitor"]]},\
"owlc_parser":{"doc":"Parses tokens into an abstract syntax tree.","i":[[0,"ast","owlc_parser","Syntax representation for owllang source code. Includes…",null,null],[0,"expressions","owlc_parser::ast","",null,null],[3,"Expr","owlc_parser::ast::expressions","Represents an expression. Expressions may or may not have…",null,null],[12,"kind","","",0,null],[12,"span","","",0,null],[4,"ExprKind","","Internal representation for `Expr`.",null,null],[13,"Literal","","Represents an int literal (internally represented using…",1,null],[13,"Identifier","","Represents an identifier expression.",1,null],[13,"FuncCall","","Represents a function call expression.",1,null],[12,"callee","owlc_parser::ast::expressions::ExprKind","",2,null],[12,"args","","",2,null],[13,"BinaryExpr","owlc_parser::ast::expressions","",1,null],[12,"lhs","owlc_parser::ast::expressions::ExprKind","",3,null],[12,"rhs","","",3,null],[12,"op_type","","The operator type of the `BinaryExpr`. Represented with a…",3,null],[0,"statements","owlc_parser::ast","",null,null],[3,"CompilationUnit","owlc_parser::ast::statements","Represents a collection of functions that are included in…",null,null],[12,"entry_file_name","","The name of the entry point file.",4,null],[12,"functions","","A compilation unit may only contain functions as top level…",4,null],[3,"Block","","Represents a block. e.g. `{...}`. A `Block` creates a new…",null,null],[12,"stmts","","The statements inside the `Block`.",5,null],[3,"FnProto","","Represents a function prototype (not the function body).…",null,null],[12,"args","","The name of the arguments as declared in the function…",6,null],[12,"iden","","The name of the function.",6,null],[3,"Stmt","","Represents a statement. Statements do not have any value…",null,null],[12,"kind","","",7,null],[12,"span","","",7,null],[4,"StmtKind","","Internal representation for `Stmt`.",null,null],[13,"Block","","Wrapper around `Block`.",8,null],[13,"Fn","","Represents a function declaration (with definition if not…",8,null],[12,"proto","owlc_parser::ast::statements::StmtKind","",9,null],[12,"body","","Field should be `None` if function is an `extern fn`.",9,null],[13,"While","owlc_parser::ast::statements","",8,null],[12,"condition","owlc_parser::ast::statements::StmtKind","`while` condition.",10,null],[12,"body","","Content of the while loop.",10,null],[13,"For","owlc_parser::ast::statements","",8,null],[13,"IfElse","","Represents an if and else statement. The else block is…",8,null],[12,"if_condition","owlc_parser::ast::statements::StmtKind","",11,null],[12,"if_body","","",11,null],[12,"else_body","","Else block is option.",11,null],[13,"Let","owlc_parser::ast::statements","",8,null],[12,"iden","owlc_parser::ast::statements::StmtKind","",12,null],[12,"initializer","","",12,null],[13,"Return","owlc_parser::ast::statements","",8,null],[12,"value","owlc_parser::ast::statements::StmtKind","",13,null],[13,"ExprSemi","owlc_parser::ast::statements","Represents an expression with semi colon (expression with…",8,null],[12,"expr","owlc_parser::ast::statements::StmtKind","",14,null],[13,"Noop","owlc_parser::ast::statements","No-op (used for empty REPL input).",8,null],[11,"new","","Create a new compilation unit for the file…",4,[[["string",3]]]],[11,"add_func","","Adds a function to the compilation unit.",4,[[["stmt",3]]]],[0,"parser","owlc_parser","Parsing logic. Transforms `Token`s into abstract syntax…",null,null],[3,"Parser","owlc_parser::parser","",null,null],[11,"new","","",15,[[["errorreporter",3],["lexer",3]]]],[11,"record_current_pos","","",15,[[],["bytepos",3]]],[11,"parse_repl_input","","User can input both fn definitions and statements /…",15,[[],["stmt",3]]],[11,"parse_compilation_unit","","",15,[[],["compilationunit",3]]],[0,"visitor","owlc_parser","Utilities for walking the abstract syntax tree.",null,null],[8,"AstVisitor","owlc_parser::visitor","",null,null],[11,"visit_expr","","Visits any `Expr` node. Uses pattern matching to dispatch…",16,[[["expr",3]]]],[11,"visit_literal_expr","","",16,[[]]],[11,"visit_identifier_expr","","",16,[[]]],[11,"visit_func_call","","",16,[[]]],[11,"visit_bin_expr","","",16,[[["expr",3],["tokenkind",4]]]],[11,"visit_stmt","","Visits any `Stmt` node. Uses pattern matching to dispatch…",16,[[["stmt",3]]]],[11,"visit_compilation_unit","","",16,[[["compilationunit",3]]]],[11,"visit_fn_proto","","",16,[[]]],[11,"visit_block","","",16,[[["block",3]]]],[11,"visit_fn_stmt","","Panics This method should panic if param `body.kind` is…",16,[[["fnproto",3],["option",4]]]],[11,"visit_while_stmt","","",16,[[["expr",3],["block",3]]]],[11,"visit_for_stmt","","",16,[[]]],[11,"visit_if_else_stmt","","",16,[[["expr",3],["block",3],["option",4]]]],[11,"visit_let_stmt","","",16,[[["expr",3]]]],[11,"visit_return_stmt","","",16,[[["expr",3]]]],[11,"visit_expr_semi_stmt","","",16,[[["expr",3]]]],[11,"from","owlc_parser::ast::expressions","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","owlc_parser::ast::statements","",4,[[]]],[11,"into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","owlc_parser::parser","",15,[[]]],[11,"into","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"fmt","owlc_parser::ast::expressions","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","owlc_parser::ast::statements","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","owlc_parser::parser","",15,[[["formatter",3]],["result",6]]],[11,"serialize","owlc_parser::ast::expressions","",1,[[],["result",4]]],[11,"serialize","","",0,[[],["result",4]]],[11,"serialize","owlc_parser::ast::statements","",4,[[],["result",4]]],[11,"serialize","","",5,[[],["result",4]]],[11,"serialize","","",6,[[],["result",4]]],[11,"serialize","","",8,[[],["result",4]]],[11,"serialize","","",7,[[],["result",4]]]],"p":[[3,"Expr"],[4,"ExprKind"],[13,"FuncCall"],[13,"BinaryExpr"],[3,"CompilationUnit"],[3,"Block"],[3,"FnProto"],[3,"Stmt"],[4,"StmtKind"],[13,"Fn"],[13,"While"],[13,"IfElse"],[13,"Let"],[13,"Return"],[13,"ExprSemi"],[3,"Parser"],[8,"AstVisitor"]]},\
"owlc_passes":{"doc":"AST passes and transformations.","i":[[0,"fn_main","owlc_passes","Makes sure main function has following signature: fn…",null,null],[3,"MainFunctionVisitor","owlc_passes::fn_main","Makes sure main function has following signature: fn…",null,null],[11,"new","","",0,[[["errorreporter",3]]]],[0,"resolver","owlc_passes","Resolving logic for symbols in the generated abstract…",null,null],[3,"SymbolTable","owlc_passes::resolver","Manages all the symbols that are currently visible.",null,null],[3,"ResolverVisitor","","Generate a map for resolving symbols in the abstract…",null,null],[12,"symbols","","",1,null],[4,"Symbol","","Represents a resolved symbol (can be either variable type…",null,null],[13,"Let","","Represents a local variable (can be created either with…",2,null],[12,"ident","owlc_passes::resolver::Symbol","",3,null],[13,"Fn","owlc_passes::resolver","Represents a function. `ident` is the identifier (name) of…",2,null],[12,"ident","owlc_passes::resolver::Symbol","",4,null],[12,"args_count","","",4,null],[4,"Scope","owlc_passes::resolver","Represents a lexical scope. A new `Scope` should be…",null,null],[13,"Block","","Represents block scope (created with `{` and destroyed…",5,null],[13,"Let","","Represents a scope created by a variable declaration…",5,null],[11,"matches","","",2,[[]]],[11,"get_symbol","","Returns `Some(symbol)` if current `Scope` contains a…",5,[[],[["symbol",4],["option",4]]]],[11,"new","","",6,[[]]],[11,"lookup","","Returns `Some(symbol)` if symbol with `ident` is found.…",6,[[],[["symbol",4],["option",4]]]],[11,"push_scope","","Pushes `scope` onto the stack.",6,[[["scope",4]]]],[11,"pop_scope","","Returns `None` if no more `Scope`s on stack.",6,[[],[["option",4],["scope",4]]]],[11,"pop_until_block","","Pops `Scope`s until a `Scope::Block` variant is found.…",6,[[],[["option",4],["scope",4]]]],[11,"new","","",1,[[["errorreporter",3]]]],[11,"from","owlc_passes::fn_main","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","owlc_passes::resolver","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"default","","",6,[[]]],[11,"eq","","",2,[[["symbol",4]]]],[11,"ne","","",2,[[["symbol",4]]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"hash","","",2,[[]]],[11,"visit_fn_proto","owlc_passes::fn_main","",0,[[]]],[11,"visit_expr","owlc_passes::resolver","",1,[[["expr",3]]]],[11,"visit_stmt","","",1,[[["stmt",3]]]],[11,"visit_fn_stmt","","",1,[[["fnproto",3],["option",4]]]],[11,"visit_block","","",1,[[["block",3]]]]],"p":[[3,"MainFunctionVisitor"],[3,"ResolverVisitor"],[4,"Symbol"],[13,"Let"],[13,"Fn"],[4,"Scope"],[3,"SymbolTable"]]},\
"owlc_source":{"doc":"Driver code for compiling a source file.","i":[[3,"SourceFile","owlc_source","",null,null],[11,"new","","Params * `name` - The name of the source file. * `source`…",0,[[]]],[11,"new_no_std","","Creates a new `SourceFile` without adding symbols from…",0,[[]]],[11,"compilation_unit","","Returns the ast generated by `parse_compilation_unit`…",0,[[],["compilationunit",3]]],[11,"repl_stmt","","Returns the ast generated by `parse_repl_input` method. #…",0,[[],["stmt",3]]],[11,"symbols","","Returns the `SymbolTable` generated by…",0,[[],["symboltable",3]]],[11,"parse_compilation_unit","","Parses the string as a compilation unit. This function…",0,[[]]],[11,"parse_repl_input","","Parses the string as a compilation unit. This function…",0,[[]]],[11,"run_pass","","Runas a pass on the generated ast. Prefer…",0,[[["astvisitor",8]]]],[11,"run_semantic_passes","","Runs passes for validating semantic checks. This should be…",0,[[]]],[11,"run_file_passes","","Runs passes specific for a file. This does not call…",0,[[]]],[11,"run_repl_passes","","Runs passes specific for REPL input. This does not call…",0,[[]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]]],"p":[[3,"SourceFile"]]},\
"owlc_span":{"doc":"Utility crate for storing syntax positions.","i":[[3,"BytePos","owlc_span","Utility for storing position in source code. Position is…",null,null],[12,"0","","",0,null],[3,"Span","","`Span` represents a region of code, used for error…",null,null],[12,"lo","","",1,null],[12,"hi","","",1,null],[3,"SourceFile","","Represents 1 `SourceFile`. NOTE: A `CompilationUnit` can…",null,null],[12,"name","","The file name.",2,null],[12,"src","","The complete source code.",2,null],[12,"newline_pos","","The locations of first char on new lines.",2,null],[6,"FileName","","Use `Rc` to prevent unnecessary duplication of the `String`.",null,null],[11,"to","","Create a new `SpanData` from `self` to `hi`. `lo` is…",0,[[["bytepos",3]],["span",3]]],[11,"zero_width_span","","Creates a \'0 width\' span. Usefull for missing AST nodes.",0,[[],["span",3]]],[11,"len","","Note: This returns the length in bytes, not chars.",1,[[]]],[11,"new","","Creates a new `SourceFile` with the given `src` string and…",2,[[]]],[11,"get_line","","Returns a slice of the source code at line `line_number`.…",2,[[],[["option",4],["cow",4]]]],[11,"count_lines","","Returns the number of lines in the source file.",2,[[]]],[11,"lookup_line","","Returns the line of the position `pos` in the source file.…",2,[[["bytepos",3]],["option",4]]],[11,"lookup_col","","Returns the col of the position `pos` in the source file.…",2,[[["bytepos",3]],["option",4]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"clone","","",0,[[],["bytepos",3]]],[11,"clone","","",1,[[],["span",3]]],[11,"cmp","","",0,[[["bytepos",3]],["ordering",4]]],[11,"eq","","",0,[[["bytepos",3]]]],[11,"ne","","",0,[[["bytepos",3]]]],[11,"eq","","",1,[[["span",3]]]],[11,"ne","","",1,[[["span",3]]]],[11,"partial_cmp","","",0,[[["bytepos",3]],[["option",4],["ordering",4]]]],[11,"lt","","",0,[[["bytepos",3]]]],[11,"le","","",0,[[["bytepos",3]]]],[11,"gt","","",0,[[["bytepos",3]]]],[11,"ge","","",0,[[["bytepos",3]]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"sub","","",0,[[["bytepos",3]]]]],"p":[[3,"BytePos"],[3,"Span"],[3,"SourceFile"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);
//! Driver code for compiling a source file.

#![forbid(unsafe_code)]

use owlc_error::ErrorReporter;
use owlc_lexer::Lexer;
use owlc_parser::ast::statements::{CompilationUnit, Stmt};
use owlc_parser::parser::Parser;
use owlc_parser::visitor::AstVisitor;
use owlc_passes::{
    fn_main::MainFunctionVisitor,
    resolver::{ResolverVisitor, SymbolTable},
};
use owlc_span::SourceFile as SourceSpan;
use std::rc::Rc;

/// `CompilationUnit` for file or `Stmt` for REPL.
#[derive(Debug)]
enum Ast {
    CompilationUnit(CompilationUnit),
    Stmt(Stmt),
}

#[derive(Debug)]
pub struct SourceFile {
    /// The name of the source file.
    name: String,
    /// The source file (string from file content).
    source_str: String,
    /// Errors (for this source file only).
    errors: ErrorReporter,
    /// Generate by parse_* function.
    ast: Option<Ast>,
    /// Generated by `run_semantic_passes`.
    symbols: Option<SymbolTable>,
    /// When `true`, will not include symbols from std.
    no_std: bool,
}
impl SourceFile {
    /// # Params
    /// * `name` - The name of the source file.
    /// * `source` - The source file content (string from file content).
    pub fn new(name: &str, source: impl Into<String>) -> Self {
        let source = source.into();
        let source_span = Rc::new(SourceSpan::new(name, &source));
        let error_reporter = ErrorReporter::new(source_span);

        Self {
            name: name.to_string(),
            source_str: source,
            errors: error_reporter,
            ast: None,
            symbols: None,
            no_std: false,
        }
    }

    /// Creates a new `SourceFile` without adding symbols from std.
    /// # Params
    /// * `name` - The name of the source file.
    /// * `source` - The source file content (string from file content).
    pub fn new_no_std(name: &str, source: impl Into<String>) -> Self {
        Self {
            no_std: true,
            ..Self::new(name, source)
        }
    }

    /// Returns the ast generated by `parse_compilation_unit` method.
    /// # Panics
    /// Panics if `SourceFile` is not parsed or if parsed REPL input.
    pub fn compilation_unit(&self) -> &CompilationUnit {
        match &self.ast {
            Some(ast) => match ast {
                Ast::CompilationUnit(res) => res,
                Ast::Stmt(_) => {
                    panic!("Parsed REPL input, not a file. Cannot get parsed CompilationUnit.")
                }
            },
            None => panic!("SourceFile has not been parsed yet. Try calling a parse_* method."),
        }
    }

    /// Returns the ast generated by `parse_repl_input` method.
    /// # Panics
    /// Panics if `SourceFile` is not parsed or if parsed file input.
    pub fn repl_stmt(&self) -> &Stmt {
        match &self.ast {
            Some(ast) => match ast {
                Ast::CompilationUnit(_) => {
                    panic!("Parsed file input, not REPL input. Cannot get parsed CompilationUnit.")
                }
                Ast::Stmt(res) => res,
            },
            None => panic!("SourceFile has not been parsed yet. Try calling a parse_* method."),
        }
    }

    /// Returns the `SymbolTable` generated by `run_semantic_passes`.
    /// # Panics
    /// Panics if semantic passes have not yet been run.
    pub fn symbols(&self) -> &SymbolTable {
        match &self.symbols {
            None => panic!("Parsed file input, not REPL input. Cannot get parsed CompilationUnit."),
            Some(symbols) => symbols,
        }
    }

    /// Parses the string as a compilation unit. This function should only be called once.
    /// # Panics
    /// Panics if this method is called when the ast has already been parsed.
    pub fn parse_compilation_unit(&mut self) {
        if self.ast.is_some() {
            panic!("SourceFile has already been parsed.");
        }

        let source_span = Rc::new(SourceSpan::new(&self.name, &self.source_str));
        let mut lexer_errors = ErrorReporter::new(source_span.clone());
        let mut lexer = Lexer::with_source_file(&source_span, &mut lexer_errors);

        let mut parser_errors = ErrorReporter::new(source_span.clone());
        let mut parser = Parser::new(&mut lexer, &mut parser_errors);

        self.ast = Some(Ast::CompilationUnit(parser.parse_compilation_unit()));
        self.errors.merge_from(&lexer_errors);
        self.errors.merge_from(&parser_errors);
    }

    /// Parses the string as a compilation unit. This function should only be called once.
    /// # Panics
    /// Panics if this method is called when the ast has already been parsed.
    pub fn parse_repl_input(&mut self) {
        if self.ast.is_some() {
            panic!("SourceFile has already been parsed.");
        }

        let source_span = Rc::new(SourceSpan::new(&self.name, &self.source_str));
        let mut lexer_errors = ErrorReporter::new(source_span.clone());
        let mut lexer = Lexer::with_source_file(&source_span, &mut lexer_errors);

        let mut parser_errors = ErrorReporter::new(source_span.clone());
        let mut parser = Parser::new(&mut lexer, &mut parser_errors);

        self.ast = Some(Ast::Stmt(parser.parse_repl_input()));
        self.errors.merge_from(&lexer_errors);
        self.errors.merge_from(&parser_errors);
    }

    /// Runas a pass on the generated ast. Prefer `run_semantic_passes`, `run_file_passes` and `run_repl_passes` over calling this method directly.
    pub fn run_pass(&mut self, visitor: &mut dyn AstVisitor) {
        let ast = match &self.ast {
            Some(ast) => ast,
            None => panic!("SourceFile has not been parsed yet. Try calling a parse_* method."),
        };

        match ast {
            Ast::CompilationUnit(ast) => visitor.visit_compilation_unit(ast),
            Ast::Stmt(ast) => visitor.visit_stmt(ast),
        }
    }

    /// Runs passes for validating semantic checks. This should be run for both file and repl.
    /// Overrides existing generated symbol table.
    /// # Passes
    /// * `ResolverVisitor` - resolves symbols.
    pub fn run_semantic_passes(&mut self) {
        let source_span = Rc::new(SourceSpan::new(&self.name, &self.source_str));

        // get symbols from std
        // make sure current SourceFile is not `std.hoot`.
        let std_symbols = if !self.no_std {
            let std_str = include_str!("../../owlc-passes/std.hoot");
            let mut std_source = Self::new_no_std("std.hoot", std_str); // set no_std:true to prevent infinite recursion
            std_source.parse_compilation_unit();
            std_source.run_semantic_passes();
            std_source.run_file_passes();
            std_source.symbols.unwrap()
        } else {
            SymbolTable::new() // empty symbol table
        };

        // resolver
        let mut resolver_errors = ErrorReporter::new(source_span.clone());
        let mut resolver = ResolverVisitor::new(&mut resolver_errors);
        resolver.symbols = std_symbols; // load symbols from std

        self.run_pass(&mut resolver);
        self.symbols = Some(resolver.symbols);

        self.errors.merge_from(&resolver_errors);
    }

    /// Runs passes specific for a file. This does not call `run_semantic_passes()`. You will need to call that manually.
    /// # Passes
    /// * `MainFunctionVisitor` - verifies `fn main()` signature.
    pub fn run_file_passes(&mut self) {
        let source_span = Rc::new(SourceSpan::new(&self.name, &self.source_str));

        // fn_main
        let mut fn_main_errors = ErrorReporter::new(source_span.clone());
        let mut fn_main = MainFunctionVisitor::new(&mut fn_main_errors);
        self.run_pass(&mut fn_main);
        self.errors.merge_from(&fn_main_errors);
    }

    /// Runs passes specific for REPL input. This does not call `run_semantic_passes()`. You will need to call that manually.
    /// # Passes
    /// None.
    pub fn run_repl_passes(&mut self) {
        let _source_span = Rc::new(SourceSpan::new(&self.name, &self.source_str));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn can_parse_sourcefile_as_file_input() {
        let mut source_file = SourceFile::new("<test>", "fn f() { return 0; }");
        source_file.parse_compilation_unit();
        let _ast = source_file.compilation_unit();

        source_file.run_semantic_passes();
        source_file.run_file_passes();

        assert!(!source_file.errors.has_errors());
    }

    #[test]
    fn can_reference_std_in_file() {
        let mut source_file = SourceFile::new("<test>", "fn f() { return println(10); }");
        source_file.parse_compilation_unit();
        let _ast = source_file.compilation_unit();

        source_file.run_semantic_passes();
        source_file.run_file_passes();

        assert!(!source_file.errors.has_errors());
    }

    #[test]
    fn can_enable_no_std() {
        let mut source_file = SourceFile::new_no_std("<test>", "fn f() { return println(10); }");
        source_file.parse_compilation_unit();
        let _ast = source_file.compilation_unit();

        source_file.run_semantic_passes();
        source_file.run_file_passes();

        assert!(source_file.errors.has_errors());
    }

    #[test]
    fn can_parse_sourcefile_as_repl_input() {
        let mut source_file = SourceFile::new("<test>", "1 + 1");
        let _repl_input = source_file.parse_repl_input();
        let _ast = source_file.repl_stmt();

        source_file.run_semantic_passes();
        source_file.run_repl_passes();

        assert!(!source_file.errors.has_errors());
    }
}
